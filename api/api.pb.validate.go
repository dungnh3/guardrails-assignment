// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/api.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	code "google.golang.org/genproto/googleapis/rpc/code"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = code.Code(0)

	_ = code.Code(0)

	_ = code.Code(0)

	_ = code.Code(0)

	_ = code.Code(0)

	_ = code.Code(0)

	_ = code.Code(0)
)

// Validate checks the field values on CreateRepositoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryRequestMultiError, or nil if none found.
func (m *CreateRepositoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := CreateRepositoryRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetLink()) < 1 {
		err := CreateRepositoryRequestValidationError{
			field:  "Link",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateRepositoryRequestMultiError(errors)
	}
	return nil
}

// CreateRepositoryRequestMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryRequestMultiError) AllErrors() []error { return m }

// CreateRepositoryRequestValidationError is the validation error returned by
// CreateRepositoryRequest.Validate if the designated constraints aren't met.
type CreateRepositoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryRequestValidationError) ErrorName() string {
	return "CreateRepositoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryRequestValidationError{}

// Validate checks the field values on CreateRepositoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepositoryResponseMultiError, or nil if none found.
func (m *CreateRepositoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRepositoryResponseMultiError(errors)
	}
	return nil
}

// CreateRepositoryResponseMultiError is an error wrapping multiple validation
// errors returned by CreateRepositoryResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateRepositoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryResponseMultiError) AllErrors() []error { return m }

// CreateRepositoryResponseValidationError is the validation error returned by
// CreateRepositoryResponse.Validate if the designated constraints aren't met.
type CreateRepositoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryResponseValidationError) ErrorName() string {
	return "CreateRepositoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryResponseValidationError{}

// Validate checks the field values on GetRepositoryByIdRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryByIdRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryByIdRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryByIdRequestMultiError, or nil if none found.
func (m *GetRepositoryByIdRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryByIdRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetRepositoryByIdRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRepositoryByIdRequestMultiError(errors)
	}
	return nil
}

// GetRepositoryByIdRequestMultiError is an error wrapping multiple validation
// errors returned by GetRepositoryByIdRequest.ValidateAll() if the designated
// constraints aren't met.
type GetRepositoryByIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryByIdRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryByIdRequestMultiError) AllErrors() []error { return m }

// GetRepositoryByIdRequestValidationError is the validation error returned by
// GetRepositoryByIdRequest.Validate if the designated constraints aren't met.
type GetRepositoryByIdRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryByIdRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryByIdRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryByIdRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryByIdRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryByIdRequestValidationError) ErrorName() string {
	return "GetRepositoryByIdRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryByIdRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryByIdRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryByIdRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryByIdRequestValidationError{}

// Validate checks the field values on GetRepositoryByIdResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryByIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryByIdResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRepositoryByIdResponseMultiError, or nil if none found.
func (m *GetRepositoryByIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryByIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRepositoryByIdResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRepositoryByIdResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRepositoryByIdResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRepositoryByIdResponseMultiError(errors)
	}
	return nil
}

// GetRepositoryByIdResponseMultiError is an error wrapping multiple validation
// errors returned by GetRepositoryByIdResponse.ValidateAll() if the
// designated constraints aren't met.
type GetRepositoryByIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryByIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryByIdResponseMultiError) AllErrors() []error { return m }

// GetRepositoryByIdResponseValidationError is the validation error returned by
// GetRepositoryByIdResponse.Validate if the designated constraints aren't met.
type GetRepositoryByIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryByIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryByIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryByIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryByIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryByIdResponseValidationError) ErrorName() string {
	return "GetRepositoryByIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryByIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryByIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryByIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryByIdResponseValidationError{}

// Validate checks the field values on ListRepositoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryRequestMultiError, or nil if none found.
func (m *ListRepositoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNextId() < 0 {
		err := ListRepositoryRequestValidationError{
			field:  "NextId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val <= 0 || val > 100 {
		err := ListRepositoryRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range (0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRepositoryRequestMultiError(errors)
	}
	return nil
}

// ListRepositoryRequestMultiError is an error wrapping multiple validation
// errors returned by ListRepositoryRequest.ValidateAll() if the designated
// constraints aren't met.
type ListRepositoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryRequestMultiError) AllErrors() []error { return m }

// ListRepositoryRequestValidationError is the validation error returned by
// ListRepositoryRequest.Validate if the designated constraints aren't met.
type ListRepositoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryRequestValidationError) ErrorName() string {
	return "ListRepositoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryRequestValidationError{}

// Validate checks the field values on ListRepositoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryResponseMultiError, or nil if none found.
func (m *ListRepositoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for NextId

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRepositoryResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRepositoryResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRepositoryResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListRepositoryResponseMultiError(errors)
	}
	return nil
}

// ListRepositoryResponseMultiError is an error wrapping multiple validation
// errors returned by ListRepositoryResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRepositoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryResponseMultiError) AllErrors() []error { return m }

// ListRepositoryResponseValidationError is the validation error returned by
// ListRepositoryResponse.Validate if the designated constraints aren't met.
type ListRepositoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryResponseValidationError) ErrorName() string {
	return "ListRepositoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryResponseValidationError{}

// Validate checks the field values on UpdateRepositoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryRequestMultiError, or nil if none found.
func (m *UpdateRepositoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := UpdateRepositoryRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 64 {
		err := UpdateRepositoryRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetLink()) < 1 {
		err := UpdateRepositoryRequestValidationError{
			field:  "Link",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateRepositoryRequestMultiError(errors)
	}
	return nil
}

// UpdateRepositoryRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryRequestMultiError) AllErrors() []error { return m }

// UpdateRepositoryRequestValidationError is the validation error returned by
// UpdateRepositoryRequest.Validate if the designated constraints aren't met.
type UpdateRepositoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryRequestValidationError) ErrorName() string {
	return "UpdateRepositoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryRequestValidationError{}

// Validate checks the field values on UpdateRepositoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRepositoryResponseMultiError, or nil if none found.
func (m *UpdateRepositoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRepositoryResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRepositoryResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRepositoryResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRepositoryResponseMultiError(errors)
	}
	return nil
}

// UpdateRepositoryResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateRepositoryResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateRepositoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryResponseMultiError) AllErrors() []error { return m }

// UpdateRepositoryResponseValidationError is the validation error returned by
// UpdateRepositoryResponse.Validate if the designated constraints aren't met.
type UpdateRepositoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryResponseValidationError) ErrorName() string {
	return "UpdateRepositoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryResponseValidationError{}

// Validate checks the field values on RemoveRepositoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveRepositoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveRepositoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveRepositoryRequestMultiError, or nil if none found.
func (m *RemoveRepositoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveRepositoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := RemoveRepositoryRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RemoveRepositoryRequestMultiError(errors)
	}
	return nil
}

// RemoveRepositoryRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveRepositoryRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveRepositoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveRepositoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveRepositoryRequestMultiError) AllErrors() []error { return m }

// RemoveRepositoryRequestValidationError is the validation error returned by
// RemoveRepositoryRequest.Validate if the designated constraints aren't met.
type RemoveRepositoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveRepositoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveRepositoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveRepositoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveRepositoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveRepositoryRequestValidationError) ErrorName() string {
	return "RemoveRepositoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveRepositoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveRepositoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveRepositoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveRepositoryRequestValidationError{}

// Validate checks the field values on RemoveRepositoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveRepositoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveRepositoryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveRepositoryResponseMultiError, or nil if none found.
func (m *RemoveRepositoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveRepositoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if len(errors) > 0 {
		return RemoveRepositoryResponseMultiError(errors)
	}
	return nil
}

// RemoveRepositoryResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveRepositoryResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveRepositoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveRepositoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveRepositoryResponseMultiError) AllErrors() []error { return m }

// RemoveRepositoryResponseValidationError is the validation error returned by
// RemoveRepositoryResponse.Validate if the designated constraints aren't met.
type RemoveRepositoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveRepositoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveRepositoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveRepositoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveRepositoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveRepositoryResponseValidationError) ErrorName() string {
	return "RemoveRepositoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveRepositoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveRepositoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveRepositoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveRepositoryResponseValidationError{}

// Validate checks the field values on TriggerScanRepositoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TriggerScanRepositoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerScanRepositoryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TriggerScanRepositoryRequestMultiError, or nil if none found.
func (m *TriggerScanRepositoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerScanRepositoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRepoId() <= 0 {
		err := TriggerScanRepositoryRequestValidationError{
			field:  "RepoId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TriggerScanRepositoryRequestMultiError(errors)
	}
	return nil
}

// TriggerScanRepositoryRequestMultiError is an error wrapping multiple
// validation errors returned by TriggerScanRepositoryRequest.ValidateAll() if
// the designated constraints aren't met.
type TriggerScanRepositoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerScanRepositoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerScanRepositoryRequestMultiError) AllErrors() []error { return m }

// TriggerScanRepositoryRequestValidationError is the validation error returned
// by TriggerScanRepositoryRequest.Validate if the designated constraints
// aren't met.
type TriggerScanRepositoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerScanRepositoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerScanRepositoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerScanRepositoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerScanRepositoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerScanRepositoryRequestValidationError) ErrorName() string {
	return "TriggerScanRepositoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TriggerScanRepositoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerScanRepositoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerScanRepositoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerScanRepositoryRequestValidationError{}

// Validate checks the field values on TriggerScanRepositoryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TriggerScanRepositoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerScanRepositoryResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TriggerScanRepositoryResponseMultiError, or nil if none found.
func (m *TriggerScanRepositoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerScanRepositoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetQueuedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TriggerScanRepositoryResponseValidationError{
					field:  "QueuedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TriggerScanRepositoryResponseValidationError{
					field:  "QueuedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueuedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TriggerScanRepositoryResponseValidationError{
				field:  "QueuedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TriggerScanRepositoryResponseMultiError(errors)
	}
	return nil
}

// TriggerScanRepositoryResponseMultiError is an error wrapping multiple
// validation errors returned by TriggerScanRepositoryResponse.ValidateAll()
// if the designated constraints aren't met.
type TriggerScanRepositoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerScanRepositoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerScanRepositoryResponseMultiError) AllErrors() []error { return m }

// TriggerScanRepositoryResponseValidationError is the validation error
// returned by TriggerScanRepositoryResponse.Validate if the designated
// constraints aren't met.
type TriggerScanRepositoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerScanRepositoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerScanRepositoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerScanRepositoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerScanRepositoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerScanRepositoryResponseValidationError) ErrorName() string {
	return "TriggerScanRepositoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TriggerScanRepositoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerScanRepositoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerScanRepositoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerScanRepositoryResponseValidationError{}

// Validate checks the field values on ListResultRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListResultRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResultRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResultRequestMultiError, or nil if none found.
func (m *ListResultRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResultRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNextId() < 0 {
		err := ListResultRequestValidationError{
			field:  "NextId",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val <= 0 || val > 100 {
		err := ListResultRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range (0, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListResultRequestMultiError(errors)
	}
	return nil
}

// ListResultRequestMultiError is an error wrapping multiple validation errors
// returned by ListResultRequest.ValidateAll() if the designated constraints
// aren't met.
type ListResultRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResultRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResultRequestMultiError) AllErrors() []error { return m }

// ListResultRequestValidationError is the validation error returned by
// ListResultRequest.Validate if the designated constraints aren't met.
type ListResultRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResultRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResultRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResultRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResultRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResultRequestValidationError) ErrorName() string {
	return "ListResultRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListResultRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResultRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResultRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResultRequestValidationError{}

// Validate checks the field values on ListResultResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResultResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResultResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResultResponseMultiError, or nil if none found.
func (m *ListResultResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResultResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for NextId

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListResultResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListResultResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListResultResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListResultResponseMultiError(errors)
	}
	return nil
}

// ListResultResponseMultiError is an error wrapping multiple validation errors
// returned by ListResultResponse.ValidateAll() if the designated constraints
// aren't met.
type ListResultResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResultResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResultResponseMultiError) AllErrors() []error { return m }

// ListResultResponseValidationError is the validation error returned by
// ListResultResponse.Validate if the designated constraints aren't met.
type ListResultResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResultResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResultResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResultResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResultResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResultResponseValidationError) ErrorName() string {
	return "ListResultResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListResultResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResultResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResultResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResultResponseValidationError{}

// Validate checks the field values on CreateRepositoryResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRepositoryResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepositoryResponse_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateRepositoryResponse_DataMultiError, or nil if none found.
func (m *CreateRepositoryResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepositoryResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSourceRepository()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepositoryResponse_DataValidationError{
					field:  "SourceRepository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepositoryResponse_DataValidationError{
					field:  "SourceRepository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceRepository()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepositoryResponse_DataValidationError{
				field:  "SourceRepository",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRepositoryResponse_DataMultiError(errors)
	}
	return nil
}

// CreateRepositoryResponse_DataMultiError is an error wrapping multiple
// validation errors returned by CreateRepositoryResponse_Data.ValidateAll()
// if the designated constraints aren't met.
type CreateRepositoryResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepositoryResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepositoryResponse_DataMultiError) AllErrors() []error { return m }

// CreateRepositoryResponse_DataValidationError is the validation error
// returned by CreateRepositoryResponse_Data.Validate if the designated
// constraints aren't met.
type CreateRepositoryResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepositoryResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepositoryResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepositoryResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepositoryResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepositoryResponse_DataValidationError) ErrorName() string {
	return "CreateRepositoryResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepositoryResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepositoryResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepositoryResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepositoryResponse_DataValidationError{}

// Validate checks the field values on GetRepositoryByIdResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRepositoryByIdResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRepositoryByIdResponse_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetRepositoryByIdResponse_DataMultiError, or nil if none found.
func (m *GetRepositoryByIdResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRepositoryByIdResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSourceRepository()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRepositoryByIdResponse_DataValidationError{
					field:  "SourceRepository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRepositoryByIdResponse_DataValidationError{
					field:  "SourceRepository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceRepository()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRepositoryByIdResponse_DataValidationError{
				field:  "SourceRepository",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRepositoryByIdResponse_DataMultiError(errors)
	}
	return nil
}

// GetRepositoryByIdResponse_DataMultiError is an error wrapping multiple
// validation errors returned by GetRepositoryByIdResponse_Data.ValidateAll()
// if the designated constraints aren't met.
type GetRepositoryByIdResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRepositoryByIdResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRepositoryByIdResponse_DataMultiError) AllErrors() []error { return m }

// GetRepositoryByIdResponse_DataValidationError is the validation error
// returned by GetRepositoryByIdResponse_Data.Validate if the designated
// constraints aren't met.
type GetRepositoryByIdResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRepositoryByIdResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRepositoryByIdResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRepositoryByIdResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRepositoryByIdResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRepositoryByIdResponse_DataValidationError) ErrorName() string {
	return "GetRepositoryByIdResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e GetRepositoryByIdResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRepositoryByIdResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRepositoryByIdResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRepositoryByIdResponse_DataValidationError{}

// Validate checks the field values on ListRepositoryResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRepositoryResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepositoryResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepositoryResponse_DataMultiError, or nil if none found.
func (m *ListRepositoryResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepositoryResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSourceRepositories() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRepositoryResponse_DataValidationError{
						field:  fmt.Sprintf("SourceRepositories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRepositoryResponse_DataValidationError{
						field:  fmt.Sprintf("SourceRepositories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRepositoryResponse_DataValidationError{
					field:  fmt.Sprintf("SourceRepositories[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRepositoryResponse_DataMultiError(errors)
	}
	return nil
}

// ListRepositoryResponse_DataMultiError is an error wrapping multiple
// validation errors returned by ListRepositoryResponse_Data.ValidateAll() if
// the designated constraints aren't met.
type ListRepositoryResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepositoryResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepositoryResponse_DataMultiError) AllErrors() []error { return m }

// ListRepositoryResponse_DataValidationError is the validation error returned
// by ListRepositoryResponse_Data.Validate if the designated constraints
// aren't met.
type ListRepositoryResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepositoryResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepositoryResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepositoryResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepositoryResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepositoryResponse_DataValidationError) ErrorName() string {
	return "ListRepositoryResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ListRepositoryResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepositoryResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepositoryResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepositoryResponse_DataValidationError{}

// Validate checks the field values on UpdateRepositoryResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRepositoryResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRepositoryResponse_Data with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateRepositoryResponse_DataMultiError, or nil if none found.
func (m *UpdateRepositoryResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRepositoryResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSourceRepository()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRepositoryResponse_DataValidationError{
					field:  "SourceRepository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRepositoryResponse_DataValidationError{
					field:  "SourceRepository",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceRepository()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRepositoryResponse_DataValidationError{
				field:  "SourceRepository",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRepositoryResponse_DataMultiError(errors)
	}
	return nil
}

// UpdateRepositoryResponse_DataMultiError is an error wrapping multiple
// validation errors returned by UpdateRepositoryResponse_Data.ValidateAll()
// if the designated constraints aren't met.
type UpdateRepositoryResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRepositoryResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRepositoryResponse_DataMultiError) AllErrors() []error { return m }

// UpdateRepositoryResponse_DataValidationError is the validation error
// returned by UpdateRepositoryResponse_Data.Validate if the designated
// constraints aren't met.
type UpdateRepositoryResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRepositoryResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRepositoryResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRepositoryResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRepositoryResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRepositoryResponse_DataValidationError) ErrorName() string {
	return "UpdateRepositoryResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRepositoryResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRepositoryResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRepositoryResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRepositoryResponse_DataValidationError{}

// Validate checks the field values on ListResultResponse_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResultResponse_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResultResponse_Data with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResultResponse_DataMultiError, or nil if none found.
func (m *ListResultResponse_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResultResponse_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListResultResponse_DataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListResultResponse_DataValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListResultResponse_DataValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListResultResponse_DataMultiError(errors)
	}
	return nil
}

// ListResultResponse_DataMultiError is an error wrapping multiple validation
// errors returned by ListResultResponse_Data.ValidateAll() if the designated
// constraints aren't met.
type ListResultResponse_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResultResponse_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResultResponse_DataMultiError) AllErrors() []error { return m }

// ListResultResponse_DataValidationError is the validation error returned by
// ListResultResponse_Data.Validate if the designated constraints aren't met.
type ListResultResponse_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResultResponse_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResultResponse_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResultResponse_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResultResponse_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResultResponse_DataValidationError) ErrorName() string {
	return "ListResultResponse_DataValidationError"
}

// Error satisfies the builtin error interface
func (e ListResultResponse_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResultResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResultResponse_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResultResponse_DataValidationError{}
